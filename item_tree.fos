///////////////////////////////////////////////////////////////////////////////
// HEADER
///////////////////////////////////////////////////////////////////////////////

#define COST_FLAG_NONE (0)
#define COST_FLAG_BASE (1)

#define FLOAT_MAX (340282346600000016151267322115014000640.000000f)
#define UINT_MAX (4294967295)

uint LogTreeLevel = 0;
bool LogTreeEnabled = true;
void LogTree(string msg) {
    if (!LogTreeEnabled) return;
    for (uint i = 0; i < LogTreeLevel; i++) {
        msg = " " + msg;
    }
    Log(msg);
}

string GetItemName(uint pid) {
    return GetConstantName(1,pid) + "<" + pid + ">";
}

// Find the maximum value of the array
float ArrayHighest(array<float> values)
{
    float result = 0.0f;
    for (uint i = 0, l = values.length; i < l; i++) {
        if (result < values[i]) {
            result = values[i];
        }
    }
    return result;
}

// Find the average value of the array
float ArrayAverage(array<float> values)
{
    if (0 == values.length) {
        return 0;
    }

    float summ = 0.0f;
    for (uint i = 0, l = values.length; i < l; i++) {
        summ += values[i];
    }
    return summ / float(values.length);
}

// Find the minimum value of the array
float ArrayLowest(array<float> values)
{
    float result = FLOAT_MAX;
    for (uint i = 0, l = values.length; i < l; i++) {
        if (result > values[i]) {
            result = values[i];
        }
    }
    return FLOAT_MAX == result ? 0.0f : result;
}

// Evaluates min max or avg value of the array
enum FilterType { None, Highest, Average, Lowest };

float Filter(array<float> values, FilterType mode) {
    if (FilterType::Highest == mode) return ArrayHighest(values);
    if (FilterType::Average == mode) return ArrayAverage(values);
    if (FilterType::Lowest == mode) return ArrayLowest(values);
    return 0.0f;
}

#ifdef __SERVER // ============================================================

// REAGENT REACTION PRODUCT
enum ReactiveType {
    ReactiveType,
    ReagentType,
    ReactionType,
    ItemReagentType,
    ToolReagentType,
    StatReagentType
}

class Reactive {
    uint get_Id() {
        return 0;
    }

    ReactiveType get_Type() {
        return ReactiveType::ReactiveType;
    }

    bool Is(Reactive@ reactive) {
        return this.Id == reactive.Id && this.Type == reactive.Type;
    }
}

class Reagent : Reactive
{
    array<Reaction@> Reactions;

    uint get_Id() override {
        return 0;
    }

    ReactiveType get_Type() override {
        return ReactiveType::ReagentType;
    }

    private float get_Weight() {
        return 0.0f;
    }

    private float get_Coefficient() {
        return 1.0f;
    }

    float CacheValue;
    FilterType CacheFilterType;

    Reagent() {
        this.CacheValue = 0.0f;
        this.CacheFilterType = FilterType::None;
    }

    void AddReaction(Reaction@ reaction) {
        if (!this.Has(reaction)) {
            this.Reactions.insertLast(reaction);
        }
    }

    bool Has(Reactive@ reactive) {
        for (uint i = 0, l = this.Reactions.length; i < l; i++) {
            if (reactive.Is(this.Reactions[i])) { 
                return true;
            }
        }
        return false;
    }

    bool Has(array<Reactive@> reactives) {
        for (uint i = 0, l = reactives.length; i < l; i++) {
            if (this.Has(reactives[i])) {
                return true;
            }
        }
        return false;
    }

    float EvaluateSelf() {
        return this.Weight * this.Coefficient;
    }

    float Evaluate(array<Reactive@> skip, FilterType filter = FitlerType::Lowest) {
        LogTree("# Creating " + GetItemName(this.Id));
        LogTreeLevel+=1;

        if (this.CacheFilterType == filter) {
            LogTreeLevel-=1;
            LogTree("$ " + GetItemName(this.Id) + " using cached price: " + this.CacheValue);
            return this.CacheValue;
        }

        // 1. Check self against the skip list
        for (uint i = 0, l = skip.length; i < l; i++) {
            if (this.Is(skip[i])) {
                LogTreeLevel-=1;
                LogTree("@ Product " + GetItemName(this.Id) + " is the same we are trying to produce");
                return -1.0f; // Push up an invalid state on match
            }
        }

        // 2. If there are no reactions leading to this product, just get the own value
        if (0 == this.Reactions.length) {
            LogTreeLevel-=1;
            LogTree("! "+GetItemName(this.Id)+"Can't be created, buying for built-in price " + this.EvaluateSelf());
            this.CacheValue = this.EvaluateSelf();
            this.CacheFilterType = filter;
            return this.CacheValue;
        }

        // 3. Add self to skip list
        skip.insertLast(this);

        string@[] logs;

        // 4. For each reaction, find out the product value
        array<float> values;
        for (uint i = 0, l = this.Reactions.length; i < l; i++) {
            LogTree("# Reaction<"+this.Reactions[i].Id+"> produces " + GetItemName(this.Id));
            this.Reactions[i].Dump();

            // 4.1 Ask reaction to evaluate the product
            float value = this.Reactions[i].Evaluate(this, skip, filter);

            LogTree("$ Reaction<"+this.Reactions[i].Id+"> price: " + value);

            // 4.2 If valid value returned, add it to the list
            if (0.0f <= value) {
                logs.insertLast("? Using reaction<"+this.Reactions[i].Id+"> for producing "+GetItemName(this.Id)+" with price: "+value);
                values.insertLast(value);
            }
        }
        for (uint i = 0; i < logs.length; i++) {
            LogTree(logs[i]);
        }

        // 5. If no values available, push up the invalid state
        if (0 == values.length) {
            LogTreeLevel-=1;
            LogTree("@ Impossible to produce " + GetItemName(this.Id) + ", using default price: " + this.EvaluateSelf());
            //return -1.0f;
            this.CacheValue = this.EvaluateSelf();
            this.CacheFilterType = filter;
            return this.CacheValue;
        }

        // 6. Return the filtered value
        this.CacheValue = this.Coefficient * Filter(values, filter);
        this.CacheFilterType = filter;
        LogTreeLevel-=1;
        LogTree("$ Product " + GetItemName(this.Id) + " calculated price: " + this.CacheValue);
        return this.CacheValue;
    }
}

class Reaction : Reactive
{
    private uint _id;
    
    private float Weight;
    private float Coefficient;

    private array<Reagent@> Reagents;
    private array<Reagent@> Products;

    uint get_Id() override {
        return this._id;
    }

    void set_Id(uint id) {
        this._id = id;
    }

    ReactiveType get_Type() override {
        return ReactiveType::ReactionType;
    }

    Reaction(uint id, float coefficient = 1.0f, float weight = 0.0f) {
        this.Id = id;
        this.Coefficient = coefficient;
        this.Weight = weight;
    }

    void AddReagents(Reagent@ reagent, uint count = 1) {
        for (uint i = 0; i < count; i++) {
            this.Reagents.insertLast(reagent);
        }
    }

    void AddProducts(Reagent@ product, uint count = 1) {
        for (uint i = 0; i < count; i++) {
            this.Products.insertLast(product);
        }
        product.AddReaction(this);
    }

    bool Has(Reactive@ reactive) {
        for (uint i = 0, l = this.Reagents.length; i < l; i++) {
            if (reactive.Is(this.Reagents[i])) {
                return true;
            }
        }
        return false;
    }

    bool Has(array<Reactive@> reactives) {
        for (uint i = 0, l = reactives.length; i < l; i++) {
            if (this.Has(reactives[i])) {
                return true;
            }
        }
        return false;
    }

    float EvaluateSelf(array<Reactive@> skip, FilterType filter = FilterType::Lowest) {
        float result = 0.0f;

        // 1. Return an invalid state if current reaction is in the skip list
        for (uint i = 0, l = skip.length; i < l; i++) {
            if (this.Is(skip[i])) {
                LogTree("@ Reaction<"+this.Id+" was peformed earlier");
                return -1.0f;
            }
        }

        // 2. Add self to skip list
        skip.insertLast(this);

        // 3. Ask each reagent to calculate its own value
        for (uint i = 0, l = this.Reagents.length; i < l; i++) {
            // Reagent should return invalid state if it believes it is in a skip list
            float value = this.Reagents[i].Evaluate(skip, filter);
            // If one does, push it up to skip the reaction
            if (value < 0.0f) {
                return value;
            }
            // Add reagent value to the summ
            result += value;
        }

        // 4. Apply own values to the result
        result += this.Weight;
        result *= this.Coefficient;

        return result;
    }

    float Evaluate(Reagent@ product, array<Reactive@> skip, FilterType filter = FilterType::Lowest) {
        // 1. Check self against the skip list, add self to it, calculate the sum of all reagents
        float value = this.EvaluateSelf(skip, filter);

        // 2. If invalid state received, push it up
        //    If there is only one product on the output, just push up the full value as well
        if (value < 0.0f || 1 >= this.Products.length) {
            return value;
        }

        // 4. Calculate the value in proportion among other products
        // 4.1 Calculate the "own value" summ for all products
        float summ = 0.0f;
        for (uint i = 0, l = this.Products.length; i < l; i++) {
            summ += this.Products[i].EvaluateSelf();
        }
        // 4.2 If summ is zero, push up the whole value
        if (summ < 0.0f) {
            return value;
        }
        // 4.3 Multitply seeked product "own value" by total value and divide it by summ of "own' values"
        return product.EvaluateSelf() * value / summ;
    }

    void Dump() {
        LogTree("+ Reaction<"+this.Id+">");
        for (uint i = 0, l = this.Reagents.length; i < l; i++) {
            LogTree("  Need: " + GetItemName(this.Reagents[i].Id));
        }
        for (uint i = 0, l = this.Products.length; i < l; i++) {
            LogTree("  Produces: " + GetItemName(this.Products[i].Id));
        }
        LogTree("- Reaction<"+this.Id+">");
    }
}

class ItemReagent : Reagent
{
    ProtoItem@ Proto;

    ItemReagent(ProtoItem@ proto) {
        @this.Proto = proto;
    }

    uint get_Id() override override {
        return uint(this.Proto.ProtoId);
    }

    ReactiveType get_Type() override {
        return ReactiveType::ItemReagentType;
    }

    float get_Weight() override {
        return float(this.Proto.Cost);
    }

    float get_Coefficient() override {
        return 1.0f;
    }
}

class ToolReagent : Reagent
{
    ProtoItem@ Proto;

    ToolReagent(ProtoItem@ proto) {
        @this.Proto = proto;
    }

    uint get_Id() override {
        return uint(this.Proto.ProtoId);
    }

    ReactiveType get_Type() override {
        return ReactiveType::ToolReagentType;
    }

    float get_Weight() override {
        return 0.0f;
    }

    float get_Coefficient() override {
        return 1.0f;
    }
}

class StatReagent : Reagent
{
    uint Stat;

    StatReagent(uint Stat) {
        this.Stat = Stat;
    }

    uint get_Id() override {
        return this.Stat;
    }

    ReactiveType get_Type() override {
        return ReactiveType::StatReagentType;
    }

    float get_Weight() override {
        return 0.0f;
    }

    float get_Coefficient() override {
        return 1.0f;
    }
}

class CraftTree
{
    array<StatReagent@> StatCache;
    array<ToolReagent@> ToolCache;
    array<ItemReagent@> ItemCache;

    void Dump() {
        for (uint i = 0, l = this.ItemCache.length; i < l; i++) {
            if (null is this.ItemCache[i]) continue;
            if (this.ItemCache[i].CacheFilterType != FilterType::None) {
                Log("& " + GetItemName(this.ItemCache[i].Id)+ ": " + this.ItemCache[i].CacheValue);
            }
        }
    }

    StatReagent@ GetStatReagent(uint id) {
        if (this.StatCache.length <= id) {
            this.StatCache.resize(1 + id);
        }
        if (null is this.StatCache[id]) {
            StatReagent reagent(id);
            @this.StatCache[id] = reagent;
        }
        return this.StatCache[id];
    }

    ToolReagent@ GetToolReagent(uint16 protoId) {
        uint pid = uint(protoId);
        if (this.ToolCache.length <= pid) {
            this.ToolCache.resize(1 + pid);
        }
        if (null is this.ToolCache[pid]) {
            ToolReagent reagent(GetProtoItem(protoId));
            @this.ToolCache[pid] = reagent;
        }
        return this.ToolCache[pid];
    }

    ItemReagent@ GetItemReagent(uint16 protoId) {
        uint pid = uint(protoId);
        if (this.ItemCache.length <= pid) {
            this.ItemCache.resize(1 + pid);
        }
        if (null is this.ItemCache[pid]) {
            ItemReagent reagent(GetProtoItem(protoId));
            @this.ItemCache[pid] = reagent;
        }
        return this.ItemCache[pid];
    }

    Reaction@ GetReaction(uint id, float coefficient = 1.0f, float weight = 0.0f) {
        Reaction reaction(id, coefficient, weight);
        return reaction;
    }

    float GetItemValue(uint16 protoId, FilterType filter = FilterType::Lowest) {
        ItemReagent@ item = this.GetItemReagent(uint(protoId));
        array<Reactive@> skip;
        float result = item.Evaluate(skip,Lowest);

        if (result < 0) {
            LogTree("$ " + GetItemName(protoId) + " has no compatible recipes, using default price: " + item.EvaluateSelf());
            result = item.EvaluateSelf();
        } else {
            LogTree("$ " + GetItemName(protoId) + " calculated price: " + result);
        }

        return result;
    }

    CraftTree() {
        array<uint16> productPidsCache;

        for (uint recipeId = 0, overflow = 0; recipeId <= UINT_MAX && overflow < 1000; recipeId++) {
            CraftItem@ recipe = GetCraftItem(recipeId);
            
            // Loop until a gap of 1000 unassigned receipts occurs
            if (null is recipe) {
                overflow++;
                continue;
            }
            overflow = 0;

            // Extract all necessary information from the receipt
            array<uint> statIds;
            array<int> statValues;
            array<bool> statOrs;
            recipe.GetNeedParams(statIds, statValues, statOrs);

            array<uint16> toolPids;
            array<uint> toolCounts;
            array<bool> toolOrs;
            recipe.GetNeedTools(toolPids, toolCounts, toolOrs);

            array<uint16> componentPids;
            array<uint> componentCounts;
            array<bool> componentOrs;
            recipe.GetNeedItems(componentPids, componentCounts, componentOrs);

            array<uint16> productPids;
            array<uint> productCounts;
            recipe.GetOutItems(productPids, productCounts);

            uint experience = recipe.Experience;

            // Create mutation for the recipe
            Reaction@ reaction = this.GetReaction(recipeId, 1.0, 0.0);
            
            /*
            // Process recipe stats
            for (uint i = 0, l = statIds.length; i < l; i++) {
                StatReagent@ element = this.GetStatReagent(statIds[i]);
                mutation.AddComponent(element);
            }
            // Process recipe tools
            for (uint i = 0, l = toolPids.length; i < l; i++) {
                ToolReagent@ element = this.GetToolReagent(toolPids[i]);
                mutation.AddComponent(element, toolCounts[i]);
            }     
            */

            // Process recipe components
            for (uint i = 0, l = componentPids.length; i < l; i++) {
                ItemReagent@ reagent = this.GetItemReagent(componentPids[i]);
                reaction.AddReagents(reagent, componentCounts[i]);
            }

            // Process recipe products
            for (uint i = 0, l = productPids.length; i < l; i++) {
                ItemReagent@ product = this.GetItemReagent(productPids[i]);
                reaction.AddProducts(product, productCounts[i]);
                productPidsCache.insertLast(productPids[i]);
            }
        }

        // Debug
        /*for (uint i = 1, l = 2; i < l; i++) {
            uint16 pid = productPidsCache[i];
            float price = this.GetItemValue(pid);
        }*/
        this.GetItemValue(377);
    }
}

///////////////////////////////////////////////////////////////////////////////
// MODULE
///////////////////////////////////////////////////////////////////////////////

void LoadItemTree() // EXPORT
{
    LogTree("Load item prototype prices...");

    CraftTree tree;
    tree.Dump();

    LogTree("Load item prototype prices complete.");
}

#endif // =====================================================================
