///////////////////////////////////////////////////////////////////////////////
// HEADER
///////////////////////////////////////////////////////////////////////////////
#define COST_FLAG_NONE (0)
#define COST_FLAG_BASE (1)

#define FLOAT_MAX (340282346600000016151267322115014000640.000000f)
#define UINT_MAX (4294967295)

// Pretty prints item pid name for logs
string GetItemName(uint pid) {
    return "[" + pid + "] " + GetConstantName(1, pid);
}

uint TreeLogOffset = 0;
array<string> TreeLogStorage;
void TreeLog(string message, int offset = 0) {
    if (offset < 0) TreeLogOffset += offset;

    string@[] line;
    for (uint i = 0; i < TreeLogOffset; i++) {
        line.insertLast(" ");
    }
    line.insertLast(message);
    TreeLogStorage.insertLast(join(line,""));

    if (offset > 0) TreeLogOffset += offset;
}
void TreeLogCommit() {
    file f;
    if (f.open("logs/item_prices.log","w") >= 0) {
        for (uint i = 0; i < TreeLogStorage.length; i++) {
            f.writeString(TreeLogStorage[i] + "\n");
        }
        f.close();
    }    
}

// Find the maximum value of the array
float ArrayHighest(array<float> values)
{
    float result = 0.0f;
    for (uint i = 0, l = values.length; i < l; i++) {
        if (result < values[i]) {
            result = values[i];
        }
    }
    return result;
}

// Find the average value of the array
float ArrayAverage(array<float> values)
{
    if (0 == values.length) {
        return 0;
    }

    float summ = 0.0f;
    for (uint i = 0, l = values.length; i < l; i++) {
        summ += values[i];
    }
    return summ / float(values.length);
}

// Find the minimum value of the array
float ArrayLowest(array<float> values)
{
    float result = FLOAT_MAX;
    for (uint i = 0, l = values.length; i < l; i++) {
        if (result > values[i]) {
            result = values[i];
        }
    }
    return FLOAT_MAX == result ? 0.0f : result;
}

// Evaluates min max or avg value of the array
enum FilterType { None, Highest, Average, Lowest };

float Filter(array<float> values, FilterType mode) {
    if (FilterType::Highest == mode) return ArrayHighest(values);
    if (FilterType::Average == mode) return ArrayAverage(values);
    if (FilterType::Lowest == mode) return ArrayLowest(values);
    return 0.0f;
}

#ifdef __SERVER // ============================================================

// REAGENT REACTION PRODUCT
enum ReactiveType {
    ReactiveType,
    ReagentType,
    ReactionType,
    ItemReagentType,
    ToolReagentType,
    StatReagentType
}

class Reactive {
    uint get_Id() {
        return 0;
    }

    ReactiveType get_Type() {
        return ReactiveType::ReactiveType;
    }

    bool Is(Reactive@ reactive) {
        return this.Id == reactive.Id && this.Type == reactive.Type;
    }
}

class Reagent : Reactive
{
    array<Reaction@> Reactions;

    uint get_Id() override {
        return 0;
    }

    ReactiveType get_Type() override {
        return ReactiveType::ReagentType;
    }

    private float get_Weight() {
        return 0.0f;
    }

    private float get_Coefficient() {
        return 1.0f;
    }

    float CacheValue;
    FilterType CacheFilterType;

    Reagent() {
        this.CacheValue = 0.0f;
        this.CacheFilterType = FilterType::None;
    }

    void AddReaction(Reaction@ reaction) {
        if (!this.Has(reaction)) {
            this.Reactions.insertLast(reaction);
        }
    }

    bool Has(Reactive@ reactive) {
        for (uint i = 0, l = this.Reactions.length; i < l; i++) {
            if (reactive.Is(this.Reactions[i])) { 
                return true;
            }
        }
        return false;
    }

    bool Has(array<Reactive@> reactives) {
        for (uint i = 0, l = reactives.length; i < l; i++) {
            if (this.Has(reactives[i])) {
                return true;
            }
        }
        return false;
    }

    float EvaluateSelf() {
        return this.Weight * this.Coefficient;
    }

    float Evaluate(array<Reactive@> skip, FilterType filter = FitlerType::Lowest) {
        TreeLog("# Creating " + GetItemName(this.Id), +1);

        if (this.CacheFilterType == filter) {
            TreeLog("$ " + GetItemName(this.Id) + " using cached price: " + this.CacheValue, -1);
            return this.CacheValue;
        }

        // 1. Check self against the skip list
        for (uint i = 0, l = skip.length; i < l; i++) {
            if (this.Is(skip[i])) {
                TreeLog("@ Product " + GetItemName(this.Id) + " is the same we are trying to produce", -1);
                return -1.0f; // Push up an invalid state on match
            }
        }

        // 2. If there are no reactions leading to this product, just get the own value
        if (0 == this.Reactions.length) {
            TreeLog("! "+GetItemName(this.Id)+" has no recipes, using proto cost " + this.EvaluateSelf(), -1);
            this.CacheValue = this.EvaluateSelf();
            this.CacheFilterType = filter;
            return this.CacheValue;
        }

        // 3. Add self to skip list
        skip.insertLast(this);

        string@[] logs;

        // 4. For each reaction, find out the product value
        array<float> values;
        for (uint i = 0, l = this.Reactions.length; i < l; i++) {
            TreeLog("# Reaction<"+this.Reactions[i].Id+"> produces " + GetItemName(this.Id));
            this.Reactions[i].Dump();

            // 4.1 Ask reaction to evaluate the product
            float value = this.Reactions[i].Evaluate(this, skip, filter);

            TreeLog("$ Reaction<"+this.Reactions[i].Id+"> price: " + value);

            // 4.2 If valid value returned, add it to the list
            if (0.0f <= value) {
                logs.insertLast("? Using reaction<"+this.Reactions[i].Id+"> for producing "+GetItemName(this.Id)+" with price: "+value);
                values.insertLast(value);
            }
        }
        
        for (uint i = 0; i < logs.length; i++) {
            TreeLog(logs[i]);
        }

        // 5. If no values available, push up the invalid state
        if (0 == values.length) {
            TreeLog("@ Impossible to produce " + GetItemName(this.Id) + ", using proto cost: " + this.EvaluateSelf(), -1);
            //return -1.0f;
            this.CacheValue = this.EvaluateSelf();
            this.CacheFilterType = filter;
            return this.CacheValue;
        }

        // 6. Return the filtered value
        this.CacheValue = this.Coefficient * Filter(values, filter);
        this.CacheFilterType = filter;
        TreeLog("$ Product " + GetItemName(this.Id) + " custom price: " + this.CacheValue, -1);
        return this.CacheValue;
    }
}

class Reaction : Reactive
{
    private uint _id;
    
    private float Weight;
    private float Coefficient;

    private array<Reagent@> Reagents;
    private array<Reagent@> Products;

    uint get_Id() override {
        return this._id;
    }

    void set_Id(uint id) {
        this._id = id;
    }

    ReactiveType get_Type() override {
        return ReactiveType::ReactionType;
    }

    Reaction(uint id, float coefficient = 1.0f, float weight = 0.0f) {
        this.Id = id;
        this.Coefficient = coefficient;
        this.Weight = weight;
    }

    void AddReagents(Reagent@ reagent, uint count = 1) {
        for (uint i = 0; i < count; i++) {
            this.Reagents.insertLast(reagent);
        }
    }

    void AddProducts(Reagent@ product, uint count = 1) {
        for (uint i = 0; i < count; i++) {
            this.Products.insertLast(product);
        }
        product.AddReaction(this);
    }

    bool Has(Reactive@ reactive) {
        for (uint i = 0, l = this.Reagents.length; i < l; i++) {
            if (reactive.Is(this.Reagents[i])) {
                return true;
            }
        }
        return false;
    }

    bool Has(array<Reactive@> reactives) {
        for (uint i = 0, l = reactives.length; i < l; i++) {
            if (this.Has(reactives[i])) {
                return true;
            }
        }
        return false;
    }

    float EvaluateSelf(array<Reactive@> skip, FilterType filter = FilterType::Lowest) {
        float result = 0.0f;

        // 1. Return an invalid state if current reaction is in the skip list
        for (uint i = 0, l = skip.length; i < l; i++) {
            if (this.Is(skip[i])) {
                TreeLog("@ Reaction<"+this.Id+" was peformed earlier");
                return -1.0f;
            }
        }

        // 2. Add self to skip list
        skip.insertLast(this);

        // 3. Ask each reagent to calculate its own value
        for (uint i = 0, l = this.Reagents.length; i < l; i++) {
            // Reagent should return invalid state if it believes it is in a skip list
            float value = this.Reagents[i].Evaluate(skip, filter);
            // If one does, push it up to skip the reaction
            if (value < 0.0f) {
                return value;
            }
            // Add reagent value to the summ
            result += value;
        }

        // 4. Apply own values to the result
        result += this.Weight;
        result *= this.Coefficient;

        return result;
    }

    float Evaluate(Reagent@ product, array<Reactive@> skip, FilterType filter = FilterType::Lowest) {
        // 1. Check self against the skip list, add self to it, calculate the sum of all reagents
        float value = this.EvaluateSelf(skip, filter);

        // 2. If invalid state received, push it up
        //    If there is only one product on the output, just push up the full value as well
        if (value < 0.0f || 1 >= this.Products.length) {
            return value;
        }

        // 4. Calculate the value in proportion among other products
        // 4.1 Calculate the "own value" summ for all products
        float summ = 0.0f;
        for (uint i = 0, l = this.Products.length; i < l; i++) {
            summ += this.Products[i].EvaluateSelf();
        }
        // 4.2 If summ is zero, push up the whole value
        if (summ < 0.0f) {
            return value;
        }
        // 4.3 Multitply seeked product "own value" by total value and divide it by summ of "own' values"
        return product.EvaluateSelf() * value / summ;
    }

    void Dump() {
        TreeLog("+ Reaction<"+this.Id+">", 1);
        for (uint i = 0, l = this.Reagents.length; i < l; i++) {
            TreeLog("Requires: " + GetItemName(this.Reagents[i].Id));
        }
        for (uint i = 0, l = this.Products.length; i < l; i++) {
            TreeLog("Produces: " + GetItemName(this.Products[i].Id));
        }
        TreeLog("- Reaction<"+this.Id+">", -1);
    }
}

class ItemReagent : Reagent
{
    ProtoItem@ Proto;

    ItemReagent(ProtoItem@ proto) {
        @this.Proto = proto;
    }

    uint get_Id() override override {
        return uint(this.Proto.ProtoId);
    }

    ReactiveType get_Type() override {
        return ReactiveType::ItemReagentType;
    }

    float get_Weight() override {
        return float(this.Proto.Cost);
    }

    float get_Coefficient() override {
        return 1.0f;
    }
}

class ToolReagent : Reagent
{
    ProtoItem@ Proto;

    float _weight;
    float _coefficient;

    ToolReagent(ProtoItem@ proto) {
        @this.Proto = proto;
        this._weight = 0.0f;
        //this._weight = float(proto.Cost) * 0.05f;
        this._coefficient = 1.0f;
    }

    uint get_Id() override {
        return uint(this.Proto.ProtoId);
    }

    ReactiveType get_Type() override {
        return ReactiveType::ToolReagentType;
    }

    float get_Weight() override {
        return this._weight;
    }

    void set_Weight(float value) {
        this._weight = value;
    }

    float get_Coefficient() override {
        return this._coefficient;
    }

    void set_Coefficient(float value) {
        this._coefficient = value;
    }
}

class StatReagent : Reagent
{
    uint Stat;
    uint Value;

    StatReagent(uint stat, uint value = 0) {
        this.Stat = stat;
        this.Value = value;
    }

    uint get_Id() override {
        return this.Stat;
    }

    ReactiveType get_Type() override {
        return ReactiveType::StatReagentType;
    }

    float get_Weight() override {
        //return float(this.Value < 0 ? 0 : this.Value); // Uncoment to add stats to value
        return 0.0f;
    }

    float get_Coefficient() override {
        return 1.0f;
    }
}

class CraftTree
{
    array<StatReagent@> StatCache;
    array<ToolReagent@> ToolCache;
    array<ItemReagent@> ItemCache;

    void Dump() {
        for (uint i = 0, l = this.ItemCache.length; i < l; i++) {
            if (this.ItemCache[i] is null) {
                continue;
            }
            uint id = this.ItemCache[i].Id;
            Log(GetItemName(id)+": $"+ceil(GetItemValue(id)));
        }
    }

    StatReagent@ GetStatReagent(uint id, uint value = 0) {
        StatReagent reagent(id,value);
        return reagent;
        /*if (this.StatCache.length <= id) {
            this.StatCache.resize(1 + id);
        }
        if (null is this.StatCache[id]) {
            StatReagent reagent(id);
            @this.StatCache[id] = reagent;
        }
        return this.StatCache[id];*/
    }

    ToolReagent@ GetToolReagent(uint16 protoId) {
        uint pid = uint(protoId);
        if (this.ToolCache.length <= pid) {
            this.ToolCache.resize(1 + pid);
        }
        if (null is this.ToolCache[pid]) {
            ToolReagent reagent(GetProtoItem(protoId));
            @this.ToolCache[pid] = reagent;
        }
        return this.ToolCache[pid];
    }

    ItemReagent@ GetItemReagent(uint16 protoId) {
        uint pid = uint(protoId);
        if (this.ItemCache.length <= pid) {
            this.ItemCache.resize(1 + pid);
        }
        if (null is this.ItemCache[pid]) {
            ItemReagent reagent(GetProtoItem(protoId));
            @this.ItemCache[pid] = reagent;
        }
        return this.ItemCache[pid];
    }

    Reaction@ GetReaction(uint id, float coefficient = 1.0f, float weight = 0.0f) {
        Reaction reaction(id, coefficient, weight);
        return reaction;
    }

    float GetItemValue(uint16 protoId, FilterType filter = FilterType::Lowest) {
        ItemReagent@ item = this.GetItemReagent(uint(protoId));
        array<Reactive@> skip;
        float result = item.Evaluate(skip,Lowest);

        if (result < 0) {
            TreeLog("$ " + GetItemName(protoId) + " has no recipes, using proto cost: " + item.EvaluateSelf());
            result = item.EvaluateSelf();
        } else {
            TreeLog("$ " + GetItemName(protoId) + " custom price: " + result);
        }

        return result;
    }

    CraftTree() {
        for (uint recipeId = 0, overflow = 0; recipeId <= UINT_MAX && overflow < 1000; recipeId++) {
            CraftItem@ recipe = GetCraftItem(recipeId);
          
            // Loop until a gap of 1000 unassigned receipts occurs
            if (null is recipe) {
                overflow++;
                continue;
            }
            overflow = 0;

            // Extract all necessary information from the receipt
            array<uint> statIds;
            array<int> statValues;
            array<bool> statOrs;
            recipe.GetNeedParams(statIds, statValues, statOrs);
            array<array<uint>> statGroups;
            array<uint> statGroup;
            for (uint i = 0; i < statOrs.length && i < statIds.length; i++) {
                statGroup.insertLast(i);

                if (statOrs[i]) {
                    if (statGroup.length > 0) {
                        statGroups.insertLast(statGroup);
                    }
                    statGroup.resize(0);
                }
            }
            if (statGroup.length > 0) {
                statGroups.insertLast(statGroup);
            }

            array<uint16> toolPids;
            array<uint> toolCounts;
            array<bool> toolOrs;
            recipe.GetNeedTools(toolPids, toolCounts, toolOrs);
            array<array<uint>> toolGroups;
            array<uint> toolGroup;
            for (uint i = 0; i < toolOrs.length && i < toolPids.length; i++) {
                toolGroup.insertLast(i);

                if (toolOrs[i]) {
                    if (toolGroup.length > 0) {
                        toolGroups.insertLast(toolGroup);
                    }
                    toolGroup.resize(0);
                }
            }
            if (toolGroup.length > 0) {
                toolGroups.insertLast(toolGroup);
            }

            array<uint16> componentPids;
            array<uint> componentCounts;
            array<bool> componentOrs; // if componentOrs[1] == true it means recipe is like "0 & 1 | 2"
            recipe.GetNeedItems(componentPids, componentCounts, componentOrs);
            array<array<uint>> componentGroups;
            array<uint> componentGroup;
            for (uint i = 0; i < componentOrs.length && i < componentPids.length; i++) {
                componentGroup.insertLast(i);

                if (componentOrs[i]) {
                    if (componentGroup.length > 0) {
                        componentGroups.insertLast(componentGroup);
                    }
                    componentGroup.resize(0);
                }
            }
            if (componentGroup.length > 0) {
                componentGroups.insertLast(componentGroup);
                componentGroup.resize(0);
            }

            array<uint16> productPids;
            array<uint> productCounts;
            recipe.GetOutItems(productPids, productCounts);

            uint experience = recipe.Experience;

            for (uint c = 0; c < componentGroups.length; c++) {
                for (uint t = 0; t < toolGroups.length; t++) {
                    for (uint s = 0; s < statGroups.length; s++) {

                        // Spawn a new recipe
                        Reaction@ reaction = this.GetReaction(recipeId, 1.0, 0.0);

                        // Add products
                        for (uint i = 0, l = productPids.length; i < l; i++) {
                            reaction.AddProducts(
                                this.GetItemReagent(productPids[i]), 
                                productCounts[i]
                            );
                        }

                        // Add components
                        for (uint i = 0; i < componentGroups[c].length; i++) {
                            reaction.AddReagents(
                                this.GetItemReagent(componentPids[componentGroups[c][i]]), 
                                componentCounts[i]
                            );
                        }

                        // Add tools
                        for (uint i = 0; i < toolGroups[t].length; i++) {
                            reaction.AddReagents(
                                this.GetToolReagent(toolPids[toolGroups[t][i]]),
                                toolCounts[i]
                            );
                        }

                        // Add stats
                        for (uint i = 0; i < statGroups[s].length; i++) {
                            reaction.AddReagents(
                                this.GetStatReagent(statIds[statGroups[s][i]]), 
                                1
                            );
                        }
                    }
                }
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// MODULE
///////////////////////////////////////////////////////////////////////////////

void LoadItemTree() // EXPORT
{
    Log("Load item prototype prices...");

    CraftTree tree;
    tree.Dump();

    Log("Load item prototype prices complete.");

    TreeLogCommit();
}

#endif // =====================================================================
